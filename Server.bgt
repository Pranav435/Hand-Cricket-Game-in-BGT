bool notout=true;
bool perm;
string winner;
network host;

void main()
{
//show_game_window("Game Server");
show_game_window("Hand-cricket multiplayer server");
tts_voice voice;
if(host.setup_server(10000, 1, 100)==false)
{
voice.speak_wait("Error. The server could not be set up.");
exit();
}
//voice.speak("Welcome to the echo server. This server will accept up to 100 connections, and send back anything it receives.");
voice.speak("Server started");
network_event event;
while(true)
{
event=host.request();
if(event.type==event_connect)
{
voice.speak_interrupt("Peer number " + event.peer_id + " connected from " + host.get_peer_address(event.peer_id) + ".");
voice.speak("Peers now connected: " + host.connected_peers + ".");
}
if(event.type==event_receive)
{
//double raw=string_to_number(event.message);
int toss=random(0,1);
string toss_choice;
//string winner;
if(toss==0)
{
toss_choice="Tails";
}
else
{
toss_choice="Heads";
}
if(event.message==toss_choice)
{
voice.speak("Client won the toss");
winner="Client";
host.send_unreliable(event.peer_id, "Client won the toss", 0);
}
else if(event.message!=toss_choice)
{
voice.speak("Host won the toss");
winner="Host";
host.send_unreliable(event.peer_id, "Host won the toss", 0);
}
break;
//voice.speak("Your choice is " + raw);
//host.send_unreliable(event.peer_id, event.message, event.channel);
//voice.speak("Message received");
}
if(event.type==event_disconnect)
{
voice.speak_interrupt("Peer number " + event.peer_id + " just disconnected.");
voice.speak("Peers now connected: " + host.connected_peers + ".");
}
if(key_down(KEY_LMENU) and key_pressed(KEY_F4))
{
voice.speak_interrupt("Exiting.");
disconnect_everyone();
// Just in case the voice hasn't finished speaking when this function returns, we wait for it to finish before actually exiting.
while(voice.speaking==true)
{
wait(5);
}
exit();
}
wait(5);
}


if(winner=="Host")
{
voice.speak("Do you want to bat or bowl first?");
string tosschoice=input_box("Choice", "Do you want to bat or bowl first?");
perm=true;
wait(5);
host.send_unreliable(event.peer_id, tosschoice, 0);
winner=tosschoice;
}
else if(winner=="Client")
{
while(true)
{
event=host.request();
if(event.type==event_receive)
{

voice.speak_wait("Client chose to " + event.message + " first.");
perm=false;
break;
}
}
if(perm)
{
voice.speak("Ok, you will " + winner + " first.");
if(winner=="Bat")
{
while(notout)
{
string num=input_box("Number", "Enter a number from 1 to 6");
double numraw=string_to_number(num);
if(numraw>6)
{
alert("DUDE!!!", "ENTER A NUMBER FROM 1 TO 6 I SAID! DON'T YOU GET INSTRUCTIONS???");
continue;
}
if(numraw<1)
{
alert("MAN", "WHY DO YOU WANT NEGATIVE SCORES???");
continue;
}
while(true)
{
event=host.request();
if(event.type==event_receive)
{
string client=event.message;
double clientraw=string_to_number(client);
if(clientraw==numraw)
{
voice.speak_wait("Oops! You, Are, Out!");
notout=false;
}

}

//else
//{
//alert("Error", "Could not compare host and client. Exiting");
//exit();
//}
}
void disconnect_everyone()
{

/*
This function first gets a list of all connected peers and disconnects them. Then it waits until it has received the same number of disconnect notifications as it sent out disconnect requests, and then returns. This may take some time, however, so we set up a timeout after which we return anyway.

Note that we are not processing messages in this event loop. You will obviously want to do this if you have other connections to manage at the same time.
*/

timer timeout;
uint[] peer_list=host.get_peer_list();
int expected_disconnects=peer_list.length();
for(uint i=0;i < peer_list.length();i++)
{
host.disconnect_peer(peer_list[i]);
}
network_event event;
while(expected_disconnects>0)
{
event=host.request();
if(event.type==event_disconnect)
{
expected_disconnects-=1;
}
if(timeout.elapsed>=1000)
{
break;
}
wait(5);
}
}
