//#include "Hand_Cricket, V 1.2.5 Main_menu update.bgt"
//#include "dynamic_menu.bgt"
//dynamic_menu network_menu;
//int menuchoice;
// Create a client that connects to a server, and gathers some statistics about the connection.

network host;

void main()
{
show_game_window("Game Client");
tts_voice voice;
uint server_id=0;  // This is used to store the ID of the remote peer that will be our server.
if(host.setup_client(1, 1)==false)
{
voice.speak_wait("Error. The client could not be set up.");
exit();
}
voice.speak("Client started.");
voice.speak("Please enter the IP address or host name that you wish to connect to.");
string address=input_box("Address", "Please enter the host name or address to connect to.");
if(address=="")
{
voice.speak_interrupt_wait("Exiting.");
exit();
}
voice.speak_interrupt("Connecting, please wait.");
host.connect(address, 10000);
network_event event;

// In this loop, we just wait for either a connect or disconnect event as this is always the first thing that we'll get.

while(true)
{
event=host.request();
if(event.type==event_connect)
{
voice.speak_interrupt("The connection to " + host.get_peer_address(event.peer_id) + " succeeded!");
server_id=event.peer_id;
//menu();
//string first;
//event=host.send_unreliable(server_id, input_box("Choice", "Enter if you want to go first or second"), 0);
//break;
string choice=input_box("Choice", "Enter Heads or Tails");

host.send_unreliable(server_id, choice, 0);
event=host.request();
voice.speak(event.message);
}
if(event.type==event_disconnect)
{
voice.speak_interrupt_wait("The connection to " + host.get_peer_address(event.peer_id) + " failed. Exiting.");
exit();
}
if(key_down(KEY_LMENU) and key_pressed(KEY_F4))
{
host.destroy();
voice.speak_interrupt_wait("Exiting.");
exit();
}
wait(5);
}

/*
Since we got here, we know that we have an active connection and can begin gathering statistics. We do this by sending roughly 30 packets per second, for 10 seconds. Then, we disconnect and speak the statistics.
*/

timer message_trigger;
timer total_time;
int sent_messages=0;
int received_messages=0;
while(true)
{
event=host.request();
if(event.type==event_disconnect)
{
host.destroy();
voice.speak_interrupt_wait("The server died. Exiting.");
exit();
}
if(event.type==event_receive)
{
received_messages+=1;
}
if(message_trigger.elapsed>=33)
{
message_trigger.restart();
host.send_unreliable(server_id, "Hello!", 0);
sent_messages+=1;
}
if(total_time.elapsed>=10000)
{
// The statistics are gathered, so we speak them.
voice.speak_interrupt("Statistics: Messages sent, " + sent_messages + ". Messages received, " + received_messages + ". Average round trip time, " + host.get_peer_average_round_trip_time(server_id) + " milliseconds. Exiting.");
disconnect_everyone();

/*
Just in case the voice hasn't finished speaking when this function returns, we wait for it to finish before actually exiting. We also allow the user to press alt+f4 since the message is pretty long.
*/
while(voice.speaking==true)
{
if(key_down(KEY_LMENU) and key_pressed(KEY_F4))
{
break;
}
wait(5);
}
exit();
}
if(key_down(KEY_LMENU) and key_pressed(KEY_F4))
{
voice.speak_interrupt("Exiting.");
disconnect_everyone();
// Just in case the voice hasn't finished speaking when this function returns, we wait for it to finish before actually exiting.
while(voice.speaking==true)
{
wait(5);
}
exit();
}
wait(5);
}
}

void disconnect_everyone()
{

/*
This is the exact same function as the one found in the server, as it works equally well for both.

This function first gets a list of all connected peers and disconnects them. Then it waits until it has received the same number of disconnect notifications as it sent out disconnect requests, and then returns. This may take some time, however, so we set up a timeout after which we return anyway.

Note that we are not processing messages in this event loop. You will obviously want to do this if you have other connections to manage at the same time.
*/

timer timeout;
uint[] peer_list=host.get_peer_list();
int expected_disconnects=peer_list.length();
for(uint i=0;i < peer_list.length();i++)
{
host.disconnect_peer(peer_list[i]);
}
network_event event;
while(expected_disconnects>0)
{
event=host.request();
if(event.type==event_disconnect)
{
expected_disconnects-=1;
}
if(timeout.elapsed>=1000)
{
break;
}
wait(5);
}
}

/*void menu()
{
network_menu.add_item_tts("Start game");
menuchoice=network_menu.run("Please choose an option",true);
if(menuchoice==1)
{
alert("Option", "Item selected was start game");
}
}*/